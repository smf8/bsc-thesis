\chapter{بررسی و ارزیابی}
در این فصل به ارزیابی‌ها و بررسی‌های انجام شده بر روی پروژه پرداخته خواهد شد.

\section{تست‌های واحد}
تست واحد\LTRfootnote{Unit Test} یکی از مهم‌ترین بخش‌های ارزیابی یک برنامه است. این مدل از ارزیابی به بررسی عملکرد یک واحد از برنامه می‌پردازد. یک واحد به معنی کوچک‌ترین بخش منزوی از یک برنامه ‌است که به صورت مستقل عمل می‌کند و ورودی و خروجی مشخصی دارد. این واحد می‌تواند بخشی از یک تابع، کل تابع و یا مجموعه‌ای از توابع باشد. از مزایای تست واحد، می‌توان به صحت سنجی عملکرد واحد‌ها نسبت به ورودی‌های مختلف اشاره کرد که کمک بسیار شایانی به اجرا‌های موفق می‌کند و ریسک عملکردهای دور از انتظار را بسیار کاهش می‌دهد. 

در زبان برنامه‌نویسی \lr{Go}، این ارزیابی‌ها در سطح بسته انجام می‌شوند. فایل‌های تست، با پسوند \texttt{\_test.go} در نام فایل مشخص شده و توسط دستور \lr{go test} اجرا می‌شود. در این پروژه، ما ارزیابی‌ها را برای واحدهای مختلفی از جمله توابع رسیدگی کننده به درخواست‌ها و یا مدل‌های تعامل با پابگاه داده انجام داده ایم. این ارزیابی‌ها با اجرا کردن توابع با انواع مختلف ورودی، خروجی تابع را با خروجی مورد انتظار مقایسه می‌کنند و در صورت وجود تفاوت ارزیابی را با وضعیت خطا تمام می‌کنند. با گسترده کردن ورودی‌های ارزیابی و تقلید\LTRfootnote{Mock} کردن نیازمندی‌ها، می‌توانیم از صحت عملکرد توابع در سناریو‌های مختلف اطمینان حاصل کنیم. همچنین با استفاده از ابزار‌های مختلفی که زبان \lr{Go} برای این هدف در اختیار توسعه دهندگان قرار داده، همانند ابزار \lr{Coverage} می‌توانیم درصد پوشش تست، یعنی تعداد خط‌های کد که این تست آن‌ها را مورد ارزیابی قرار داده پیدا کنیم و مطمین شویم که کل واحد مورد ارزیابی قرار گرفته است.

% اینجا باید اسکرین شات از یونیت تست بذاریم

\section{تست‌های ادغام}
تست ادغام\LTRfootnote{Integration Test} به معنی تست کلی سامانه و ارزیابی عملکرد چندین بخش از سامانه در کنار یکدیگر است. این تست می‌تواند در داخل خود کد و همانند تست‌های واحد در قالب فایل‌های \texttt{\_test.gi} باشد. و هم می‌تواند توسط ابزار‌های خارجی و با نسخه درحال اجرای برنامه اجرا شود. یک مثال از این مدل ارزیابی، اجرای فرایند ثبت‌نام و ورود کاربر به صورت تعاملی\LTRfootnote{Interactive} با سامانه است. برای این‌کار، ابتدا با یک درخواست اقدام به ساخت حساب کاربری می‌کنیم. سپس با اطلاعات استفاده شده در مرحله قبل، اقدام به ورود و دریافت کلید ورود می‌کنیم. سپس با ارزیابی کلید ورود متوجه عملکرد این قسمت از سامانه می‌شویم.

با توجه به پیاده‌سازی رابط‌های ارتباطی وب در این پروژه با استاندارد \lr{Open API}، تمامی مقصد‌های تعریف شده. قابلیت اجرا با ورودی دلخواه توسط ابزار‌های تست \lr{API} نظیر \lr{Postman} یا \lr{K6} را دارند.

% اینجا باید یک یا چندتا تست پست من درست بکنیم و اضافه بکنیم اینجا.

\section{تست بار}
تست بار\LTRfootnote{Load Test} به دسته‌ای از تست‌ها گفته می‌شود که عملکرد سامانه و الگوی مصرف از منابع و میزان مصرف از منابع را در سناریو‌های تحت فشار شدید ارزیابی می‌کنند. معمولا این تست‌ها عملکردی ساده از سامانه که می‌تواند یک تست ادغام باشد را به صورت موازی توسط چندین کاربر اجرا می‌کنند. نتایج این تست به توسعه دهندگان این امکان را می‌دهد که نسبت حجم درخواست به منابع مصرفی و سرعت پاسخگویی برنامه را متوجه شوند و در صورت نیاز سناریو‌های مقیاس پذیری یا بهبود‌های عملکردی را طراحی کنند.

این تست‌ها در این پروژه به دو صورت انجام شده، دسته اول از تست‌ها در قالب فایل‌های \lr{Benchmark} اضافه شده. یکی از قابلیت‌های زبان برنامه‌نویسی \lr{Go}، امکان تعریف \lr{Benchmark} برای قسمت‌های مختلف برنامه است. این توابع همانند تست‌های واحد، می‌توانند واحد مشخصی از برنامه را با حجم متغیری از ورودی اجرا کنند و نتیجه را به تفکیک سرعت اجرا و منابع مصرفی برای کاربر نمایش دهند. 

% یک بنچمارک و نتیجه اش رو باید اینجا بذاریم

نوع دیگر انجام تست بار، توسط ابزار‌های خارجی اجرا می‌شود و عملکرد کلی برنامه‌را در سناریو‌های پیچیده‌تر ارزیابی می‌کند. یکی از ابزار‌های مورد استفاده در این بخش، ابزار k6 است. با نوشتن و طراحی سناریو و مشخص کردن نوع و حجم بار ورودی به سامانه، با اجرای این برنامه، می‌توانیم عملکرد سامانه را نسبت به حجم بار ورودی ارزیابی کنیم و در نهایت صحت عملکرد پاسخ‌ها را نیز دریافت کنیم.

% نمونه ای از اجرای k6 و جوابش


\section{محدودیت‌ها}
با توجه به معماری استفاده‌شده در پیاده‌سازی این سامانه، تمامی خدمت‌گزار‌های سامانه و پایگاه داده می‌توانند به صورت افقی مقیاس شوند تا پاسخگوی حجم‌های احتمالی زیاد باشند. با این وجود بخش‌هایی از سامانه محدودیت‌هایی در راستای حجم فشار کلی سامانه ایجاد می‌کنند.


اولین محدودیت سامانه، عدم امکان مقیاس کردن زمان‌بند سرویس خادم است. این زمان‌بند به صورت مستقیم با کاربران در تعامل نیست و در نتیجه حجم درخواست‌های ناگهانی بار اصلا تاثیرگذار نیست. اما بالا رفتن تعداد منابع ساخته‌شده، یا فشار زیاد شبکه، باعث اختلال در عملکرد و فشار بر این برنامه می‌شود. راه حل کمتر کردن این فشار، رزرو کردن منابع اختصاصی شبکه برای این برنامه در کنار زیاد کردن منابع محاسباتی پیش از اجرا است.

یکی دیگر از محدودیت‌های سامانه که مقیاس شدن برنامه در آن تاثیر کمی دارد، زیرساخت \lr{cloud director} است. با توجه به ساختار تک نسخه‌ای بودن آن در برنامه، تمامی نسخه‌های سرویس خادم با یک نسخه‌از \lr{cloud director} در ارتباط هستند. از آنجایی که عملیات‌های تعریف شده در این برنامه، ذاتا زمان‌بر هستند و نیازمند اجرا به صورت آسنکرون هستند. اجرای حجم زیادی از درخواست‌ها و ارسال آن‌ها به سمت \lr{cloud director} می‌تواند باعث بروز اختلال و اعمال فشار بر این سرویس شود. راه حل پیشنهادی جهت بهبود این محدودیت، تعریف سقف برای تعداد عملیات‌های در حال اجرا در سمت خادم است. این‌کار می‌تواند با قرار دادن یک صف پیام\LTRfootnote{Message Queue} بین سرویس باجه و خادم انجام شود.

\clearpage
\section{خطایابی}
عملکرد مورد انتظار رابط‌های برنامه‌نویسی برنامه در فایل‌های \lr{Open API Specification} نوشته‌شده، می‌توان این فایل‌ها را با استفاده از ابزار \lr{Swagger} بررسی کرد. در صورتی که سامانه نتیجه‌ای غیر از نتیجه انتظار برگرداند. خطایابی با استفاده از کد وضعیت برگردانده شده به همراه پیام\LTRfootnote{Message} پاسخ می‌تواند انجام شود. در صورت نیاز به اطلاعات بیشتر، برنامه‌ها خطا‌های رخ‌داده را داخل \lr{Std Error} محیط اجرایی چاپ می‌کنند. در صورت اجرا در قالب بسته‌های داکر، چک کردن این خطا‌ها می‌تواند با دستور \lr{docker logs} انجام شود. با توجه به سطوح مختلف اطلاع رسانی خطا، تنظیمات چاپ رخداد‌ها را می‌شود داخل فایل \lr{config} تغییر داد. درجات مختلف چاپ جزئیات در لیست زیر نوشته شده. در این لیست اولین عضو به معنی کمترین جزئیات و آخرین عضو به معنی بیشترین جزئیات است.

\begin{enumerate}
	\item \texttt{panic}
	\item \texttt{fatal}
	\item \texttt{error}
	\item \texttt{warning}
	\item \texttt{info}
	\item \texttt{debug}
\end{enumerate}
